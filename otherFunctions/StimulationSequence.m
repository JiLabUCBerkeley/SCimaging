function [order,point_trial_angle,output]=StimulationSequence(filePath,fileName,pp)
% StimulationSequence is to obtain stimulation sequence generated by f21;
% filePath is the path where log files are saved; fileName contains names
% of tif stacks (could be more); pp is a column, image quantities for each tif stacks
% order is a cell type; length of the order is corresponding to the session
% number;  each element of order has 4 columns. 
% The first column is the angle sequence in degree for individual images; the
% second column is the index (1,2,3,4,... to number of frames); the third column is one by
% sorting the 1st column, and the fourth column is reorganized index of the
% 2nd column; order{1}(:,3)=order{1}(order{1}(:,4),1);

% Writen by Rongwen Lu 07/31/2016

% h_wait = waitbar(0.2,'get sequence');
p=length(fileName);
order=cell(p,1);
point_trial_angle=zeros(p,3);
id=1:11;
if length(pp)==1
    pp=ones(p,1)*pp;
end
output=cell(p,1);
for ii=1:p
    file1=fileName(ii).name;
    fileTmp=dir(fullfile(filePath,[file1(id),'*.log']));
    if ~isempty(fileTmp)
    [order(ii),point_trial_angle(ii,:)]=StimulationSequence_singleLog(filePath,fileName,pp(ii),id);
    else
         fileTmp=dir(fullfile(filePath,[file1(id),'*.mat']));%file1=fileName(ii).name;
        if ~isempty(fileTmp)
        [orderTmp,point_trial_angleTmp,logFlag,output{ii}]=StimulationSequence_singleMat(filePath,fileName(ii),pp(ii),id);
        if logFlag==1
            order(ii)=orderTmp;
            point_trial_angle(ii,:)=point_trial_angleTmp;
        end       
    end

    
    
    end    
    
end
function [order,point_trial_angle,logFlag,output]=StimulationSequence_singleMat(filePath,fileName,pp,id)
p=length(fileName);
logFiles=cell(p,1);
if length(pp)==1 && p>1
    pp=ones(p,1)*pp;
end
order=cell(p,1);
point_trial_angle=zeros(p,3);
logFlag=0;

for ii=p:-1:1
    file1=fileName(ii).name;
    fileTmp=dir(fullfile(filePath,[file1(id),'*.mat']));
    logFiles{ii}=fullfile(filePath,fileTmp(1).name);
    
    if ~isempty(logFiles{ii})
        matObj=matfile(logFiles{ii});
        output=load(logFiles{ii});
        if ~isempty(whos(matObj,'sequenceAngle'))
            orderTmp1=matObj.sequenceAngle;
            orderTmp2=orderTmp1(:);
            trial_angle=[matObj.trialNO,matObj.angleNO];
            repeatNO=pp(ii)./trial_angle(:,1)./trial_angle(:,2);
            repeatNO=floor(repeatNO);
            orderTmp3=ones(repeatNO,1)*orderTmp2.';
            orderTmp4=orderTmp3(:);
            p2=length(orderTmp4);
              p1=p2;
                if p1<p2
                    orderTmp4=orderTmp4(1:p1);

                end 
                [Y,I]=sort(orderTmp4);
                order{ii}=[orderTmp4(:)*1,(1:length(I)).',Y(:)*1,I(:)]; 
                point_trial_angle(ii,:)=[repeatNO,trial_angle];
                logFlag=1;
            elseif ~isempty(whos(matObj,'freq_pool')) %% for Yajie spatial mapping and temporal mapping
            orderTmpa=matObj.freq_pool;
            orderTmpb=matObj.cyclespersec_pool;
            if length(orderTmpb)==1
                orderTmp1=orderTmpa/0.003727272727273;
            elseif length(orderTmpa)==1
                orderTmp1=orderTmpb;
                
            end
            if ~isempty(whos(matObj,'contrastRaw2'))
                orderTmp1=30*(orderTmpa-1);
%                 trial_angle=[matObj.trialNO,length(orderTmp1)/matObj.trialNO];
                orderTmp1=360/(length(orderTmp1)/matObj.trialNO)*(orderTmpa-1);
            end
            
            orderTmp2=orderTmp1(:);
            trial_angle=[matObj.trialNO,length(orderTmp1)/matObj.trialNO];
            repeatNO=pp(ii)./trial_angle(:,1)./trial_angle(:,2);
            repeatNO=floor(repeatNO);
            orderTmp3=ones(repeatNO,1)*orderTmp2.';
            orderTmp4=orderTmp3(:);
            p2=length(orderTmp4);
              p1=p2;
                if p1<p2
                    orderTmp4=orderTmp4(1:p1);

                end 
                [Y,I]=sort(orderTmp4);
                order{ii}=[orderTmp4(:)*1,(1:length(I)).',Y(:)*1,I(:)]; 
                point_trial_angle(ii,:)=[repeatNO,trial_angle];
                logFlag=1;

        end
    else
        output=nan;
    end
      
end



function [order,point_trial_angle]=StimulationSequence_singleLog(filePath,fileName,pp,id)
p=length(fileName);
logFiles=cell(p,1);

for ii=p:-1:1
    file1=fileName(ii).name;
    fileTmp=dir(fullfile(filePath,[file1(id),'*.log']));
    logFiles{ii}=fullfile(filePath,fileTmp(1).name);
end
p=length(logFiles);
% get log file info
f21_log=cell(p,1);
for ii=1:p
    if ~isempty(logFiles{ii})
        f21_log{ii} = f21log_load(logFiles{ii});
    end
    
end

%  waitbar(1, h_wait,'get sequence');
%% get sequence
[trial_angle,gad2Flag]=obtainQuantity(f21_log);
p=length(gad2Flag);
if length(pp)==1
    imgN=pp*ones(p,1);
else
    imgN=pp(:);
end
repeatNO=imgN./trial_angle(:,1)./trial_angle(:,2);
repeatNO=floor(repeatNO);
order=getStimulusSequence(f21_log,repeatNO,gad2Flag);
point_trial_angle=[repeatNO,trial_angle];
% close(h_wait);


function [trial_angle,gad2Flag]=obtainQuantity(f21_log)

p2=length(f21_log);
trial_angle=zeros(p2,2);
gad2Flag=zeros(p2,1);
for ii=1:p2
    if ~isempty(f21_log{ii})
        if f21_log{ii}.isvalid==1
            trial_angle(ii,:)=[f21_log{ii}.repeats,f21_log{ii}.data_points];
        else
            trial_angle(ii,:)=[8,8];
            gad2Flag(ii)=1;

        end
    else
        trial_angle(ii,:)=[8,8];gad2Flag(ii)=1;
    end    

end





function f21_log = f21log_load(logfile)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%Load and prorcess the log file
if ~isequal(exist(logfile), 2)
    disp('Can not find the log file, the program will stop!!');
    return;
end

lines = f21log_get(logfile);
if ~iscellstr(lines)
   % errordlg('Can''t load log file data correctly.','File Load Error','replace')
   f21_log.isvalid = 0;
   return;
end

% search log file data
file_type = f21log_search(lines,'FileInfo','FileType','JQK');
if ~strcmp(file_type,'f21lv test log file')
%    % errordlg('This is not a valid f21 log file.','File Type Error','replace')
   f21_log.isvalid = 0;
   return;
end

f21_log.file_type = file_type;

file_version = f21log_search(lines,'FileInfo','FileVersion','JQK');
if ~strcmp(file_version,'2.0')
%    % errordlg('Only version 2.0 log file is supported.','File Version Error','replace')
   f21_log.isvalid = 0;
   return;
else
    f21_log.isvalid = 1;
end
f21_log.file_version = file_version;

file_time = f21log_search(lines,'FileInfo','FileTime','NULL');
f21_log.stop_time = file_time;

test_type = f21log_search(lines,'TestInfo','TestType','JQK');
if ~strcmp(test_type,'tuning curve')
   % % errordlg('This is not a tuning curve test log file.','Test Type Error','replace')
   f21_log.isvalid = 0;
   return;
end
f21_log.test_type = test_type;

test_name = f21log_search(lines,'TestInfo','Testname','JQK');
f21_log.test_name = test_name;

str_temp = f21log_search(lines,'TestInfo','RemoteRefreshRate','1');
remote_refresh_rate = sscanf(str_temp,'%f');
f21_log.remote_refresh_rate = remote_refresh_rate;

str_temp = f21log_search(lines,'TestInfo','RefreshRate','1');
refresh_rate = sscanf(str_temp,'%f');
f21_log.refresh_rate = refresh_rate;

% use 0.1 ms as an unit comparing to 10khz acq rate;
UNIT_PER_SEC = 1000*10;
unit_per_frame = UNIT_PER_SEC/refresh_rate;
f21_log.unit_per_frame = unit_per_frame;

tc_mode = f21log_search(lines,'TunningCurve','TCMode','JQK');
if strcmp(tc_mode,'JQK')
   % errordlg('This is not a new-style tuning curve test log file.','TC Type Error','replace')
   f21_log.isvalid = 0;
   return
end
f21_log.tc_mode = tc_mode;

gratings_type = f21log_search(lines,'TunningCurve','CRFShowType','JQK');
f21_log.gratings_type = gratings_type;

str_temp = f21log_search(lines,'TunningCurve','OriX','9999');
ori_x = sscanf(str_temp,'%f');
f21_log.ori_x = ori_x;

str_temp = f21log_search(lines,'TunningCurve','OriY','9999');
ori_y = sscanf(str_temp,'%f');
f21_log.ori_y = ori_y;

str_temp = f21log_search(lines,'TunningCurve','GratingsW','9999');
gratings_w = sscanf(str_temp,'%f');
f21_log.gratings_w = gratings_w;

str_temp = f21log_search(lines,'TunningCurve','GratingsH','9999');
gratings_h = sscanf(str_temp,'%f');
f21_log.gratings_h = gratings_h;

str_temp = f21log_search(lines,'TunningCurve','GratingsSpatialFrequency','9999');
gratings_spatial_frequency = sscanf(str_temp,'%f');
f21_log.gratings_spatial_frequency = gratings_spatial_frequency;

str_temp = f21log_search(lines,'TunningCurve','GratingsTemporalFrequency','9999');
gratings_temporal_frequency = sscanf(str_temp,'%f');
f21_log.gratings_temporal_frequency = gratings_temporal_frequency;

str_temp = f21log_search(lines,'TunningCurve','CRFSize','9999');
crf_size = sscanf(str_temp,'%f');
f21_log.crf_size = crf_size;

str_temp = f21log_search(lines,'TunningCurve','CRFDirection','9999');
crf_dirrection = sscanf(str_temp,'%f');
f21_log.crf_dirrection = crf_dirrection;

str_temp = f21log_search(lines,'TunningCurve','nCRFRatio','9999');
ncrf_ratio= sscanf(str_temp,'%f');
f21_log.ncrf_ratio = ncrf_ratio;

str_temp = f21log_search(lines,'TunningCurve','nCRFSize','9999');
ncrf_size= sscanf(str_temp,'%f');
f21_log.ncrf_size = ncrf_size;

str_temp = f21log_search(lines,'TunningCurve','nCRFDirection','9999');
ncrf_direction= sscanf(str_temp,'%f');
f21_log.ncrf_direction = ncrf_direction;

str_temp = f21log_search(lines,'TunningCurve','nCRFContrast','9999');
ncrf_contrast = sscanf(str_temp,'%f');
log.ncrf_contrast = ncrf_contrast;

str_temp = f21log_search(lines,'TunningCurve','OuterDirection','9999');
outer_direction = sscanf(str_temp,'%f');
f21_log.outer_direction = outer_direction;

str_temp = f21log_search(lines,'TunningCurve','SingleTestTime','1');
single_test_time = sscanf(str_temp,'%d');
f21_log.single_test_time = single_test_time;

str_temp = f21log_search(lines,'TunningCurve','Interval','0');
interval = sscanf(str_temp,'%d');
f21_log.interval = interval;

str_temp = f21log_search(lines,'TunningCurve','DataPoints','1');
data_points = sscanf(str_temp,'%d');
f21_log.data_points = data_points;

str_temp = f21log_search(lines,'TunningCurve','Repeats','1');
repeats = sscanf(str_temp,'%d');
f21_log.repeats = repeats;

str_temp = f21log_search(lines,'TunningCurve','DirectionList','1 0');
list_temp = sscanf(str_temp,'%f');
direction_list = list_temp(2:length(list_temp));
f21_log.direction_list = direction_list;

str_temp = f21log_search(lines,'TunningCurve','SpatialList','1 0');
list_temp = sscanf(str_temp,'%f');
spatial_list = list_temp(2:length(list_temp));
f21_log.spatial_list = spatial_list;

str_temp = f21log_search(lines,'TunningCurve','TemporalList','1 0');
list_temp = sscanf(str_temp,'%f');
temporal_list = list_temp(2:length(list_temp));
f21_log.temporal_list = temporal_list;

str_temp = f21log_search(lines,'TunningCurve','TestSequence','1 0');
list_temp = sscanf(str_temp,'%f');
test_sequence = list_temp(2:length(list_temp));
f21_log.test_sequence = reshape(test_sequence,f21_log.data_points, f21_log.repeats);



sort_sequence = zeros(data_points, repeats);
for i=1:repeats
    tmp = test_sequence(((i-1)*data_points+1):(i*data_points));
    [seq inx] = sort(tmp);
    sort_sequence(:,i) = inx;
end
f21_log.sort_sequence = sort_sequence;

str_temp = f21log_search(lines,'TunningCurve','TestValueSequence','1 0');
list_temp = sscanf(str_temp,'%f');
test_value_sequence = list_temp(2:length(list_temp));
f21_log.test_value_sequence = test_value_sequence;

sort_value_sequence = test_value_sequence(sort_sequence(:,1));
f21_log.sort_value_sequence = sort_value_sequence;

return;



%%

%read f21 log file information into a cell.
%     lines = flog_load(filename);
%
%     INPUTS
%     filename   - filename (string) of the log file
%  
%     OUTPUTS
%     lines - line array 
%
%     if fails, return 0

function lines = f21log_get(filename)

% open file
[fid,message] = fopen(filename,'rt');
if fid < 0
   fprintf('\n%s\n',message);
   lines = 0;
   return;
end

% load file into str
str = fscanf(fid,'%c');

% close file
fclose(fid);

% convert str to line cell array
lines = str2cell(str);

return



function value = f21log_search(lines,section,keyword,default,prompt_not_found);
% FSEARCH_LOG               Retrieve information from f21 log lines
% 
%     value = f21log_search(lines,section,keyword,default,prompt_not_found);
%
%     INPUTS
%     lines      - log line array (return value of fload_log)
%     section    - section name (string) in log file (like [XXX])
%     keyword    - entry name (string) in log file
%     defualt    - return value (string) if expected section-keyword pair not found
%  
%     OUTPUTS
%     value - string returned 
%
%     Yuxi 07.18.2000
%
%     $ Version 1.0 - Yuxi 07.18.2000 - initial version $

if nargin < 4
   fprintf('\nFSEARCH_LOG, no enough input arguments, type ''help fsearch_log'' for help\n\n');
   value = default;
   return;
end

if nargin < 5
   prompt_unfound = 0;
else
   prompt_unfound = prompt_not_found;
end

% length of keyword segment in log file
div = 30;

% flag and counter
count = 1;

% convert section name 'XXX' to '[XXX]' 
section_str = sprintf('[%s]',section);

% not found message
not_found_msg = sprintf('\n  %s\n',['fsearch_log, ' section ', ' keyword ', not found !']);

% get length line cell array
numlines = length(lines);

% Loop through the cell array until section_str and keyword are found
while 1
   % check if exceed lines dimension
   if count > numlines
      if prompt_unfound fprintf(not_found_msg); end
      value = sprintf('%s',default);
      return;
   end
   
   % search section
   if isempty(lines{count})
      % Do nothing if blank line
      count = count + 1;
   elseif strcmp(deblank(lines{count}),section_str)
      count = count + 1;
      while 1
         if count > numlines
            if prompt_unfound fprintf(not_found_msg); end
            value = sprintf('%s',default);
            return;
         end
         
         % search keyword
         if isempty(lines{count})
            count = count +1;
         elseif strcmp(lines{count}(1),'[')
            break;
         elseif strcmp(deblank(lines{count}(1:div)),keyword)
            value = lines{count}(div+1:length(lines{count}));
       %     value = strjust(value,'left');
            value = deblank(value);
            return;
         else
            count = count + 1;
         end
      end
   else
      count = count + 1; 
   end
end

return
% STR2CELL               Convert a string to a cell array of lines.
%
%     C = STR2CELL( STR ) creates a cell array C where each cell contains
%     a line of the string STR.
%
%     C = STR2CELL( STR, OPTS ), where OPTS is 'L', 'T' or both, removes
%     leading and/or trailing blank lines from the string before
%     converting to a cell array.
%
%     If the string contains LFs (linefeed characters, decimal 10), the
%     input string is split at their position after all CRs (carriage
%     return characters, decimal 13) have been removed. If there are no
%     LFs, the string is split at the position of the CRs. This should
%     ensure that the string is split correctly with both UNIX (LF), DOS
%     (CR+LF) and MAC (CR) definitions of a newline.

%     Author:      Peter J. Acklam
%     Time-stamp:  1998-06-30 21:20:01
%     E-mail:      jacklam@math.uio.no
%     WWW URL:     http://www.math.uio.no/~jacklam

function c = str2cell( varargin )

error( nargchk( 1, 3, nargin ) );

%
% Assign default values to parameters that can be changed by command
% line options.
%
strip_lead  = 0;
strip_trail = 0;

%
% Process command line options.
%
while length( varargin ) > 1
   opt = varargin{2};
   if ~ischar( opt )
      error( 'Options must be strings.' );
   end
   switch opt
      case { 'l', 'L' }
         strip_lead = 1;
      case { 'u', 'U' }
         strip_trail = 1;
      otherwise
         error( [ 'Unknown option: ' opt ] );
   end
   varargin(2) = [];
end
str = varargin{1};

%
% Strip leading blank lines.
%
if strip_lead
   k = find( ~isspace(str) );
   if ~isempty(k)
      k = min(k);
      str = str(k:end);
   end
end

%
% Strip trailing blank lines.
%
if strip_trail
   k = find( ~isspace(str) );
   if ~isempty(k)
      k = max(k);
      str = str(1:k);
   end
end

%
% Quick exit if string is empty.
%
if isempty( str )
   c = { '' };
   return
end

%
% Find the characters that separate the lines.
%
k = find( str == 10 );                  % Find all LF (/n) chars. /n
l = find( str == 13 );                  % Find all CR (return) chars.
if isempty( k )                         % If no LF chars were found
   k = l;                               %   split at CR chars.
else                                    % Or else
   if ~isempty( l )                     % If there are CR chars
      str(l) = [];                      % remove them.
      k = find( str == 10 );            % refind all LF chars.
   end
end

%
% Avoid empty last string in output list when string ends in a newline.
%
if ~isempty( k ) & k(end) == length(str)
   k = [ 0 k ];                         % Add beginning.
else
   k = [ 0 k length(str)+1 ];           % Add beginning and end.
end

%
% Now split the string into lines.
%
n = length(k) - 1;                      % Number of lines.
c = cell( n, 1 );                       % Initialize output.
for i = 1:n
   c{i} = str( k(i)+1 : k(i+1)-1 );     % Extract line.
end
function order=getStimulusSequence(f21_log,repeatNO,gad2Flag)

p=length(f21_log);

order=cell(p,1);
for ii=1:p
    ii
    if gad2Flag(ii)==1
        %% note: the 1st column of orderTmp1 is the 1st trial; and 2nd column is the second trial; people may make mistake by taking the first row as the first trial.
        orderTmp1=45*[0,3,4,6,6,0,4,6;5,4,2,1,7,2,6,4;3,7,7,7,1,4,1,1;4,5,1,5,3,6,7,2;7,1,3,2,5,1,5,7;1,6,5,3,4,3,3,0;2,2,6,0,2,7,2,5;6,0,0,4,0,5,0,3];
        
        orderTmp2=orderTmp1(:);        
    else
        orderTmp2=f21_log{ii}.test_value_sequence(:);

    end
    orderTmp3=ones(repeatNO(ii),1)*orderTmp2.';
    orderTmp4=orderTmp3(:);
    % for future use
          p2=length(orderTmp4);
          p1=p2;
            if p1<p2
                orderTmp4=orderTmp4(1:p1);
            end 
            [Y,I]=sort(orderTmp4);
            order{ii}=[orderTmp4(:)*1,(1:length(I)).',Y(:)*1,I(:)];        
end

